#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
CA360 Chat Application - Main Application
Ultra-Clean Professional Architecture with Enterprise-Grade Session Management
"""

# Monkey patching is handled by Gunicorn's eventlet worker
# DO NOT call eventlet.monkey_patch() here to avoid double-patching

from flask import Flask, send_from_directory, make_response, request, jsonify, session, render_template, redirect
from datetime import datetime
from flask_login import LoginManager, login_required
from flask_socketio import SocketIO
from flask_cors import CORS
import os

# Import configurations
from config import (
    SECRET_KEY, SESSION_LIFETIME, SESSION_COOKIE_NAME,
    SESSION_COOKIE_SAMESITE, SESSION_COOKIE_SECURE,
    SESSION_COOKIE_HTTPONLY, SESSION_COOKIE_DOMAIN,
    TIMEZONE, UPLOAD_FOLDER, MAX_FILE_SIZE,
    # Import TURN/WebRTC configuration
    TURN_SECRET, METERED_API_KEY, METERED_SECRET_KEY,
    METERED_TURN_URLS, OPENRELAY_USERNAME, OPENRELAY_CREDENTIAL,
    OPENRELAY_TURN_URLS, GOOGLE_STUN_SERVERS, CLOUDFLARE_STUN,
    get_ice_servers, get_webrtc_config
)

# Import route blueprints
from routes.auth_routes import auth_bp
from routes.user_routes import user_bp
from routes.message_routes import message_bp, init_socketio as init_message_socketio
from routes.database_routes import database_bp

# Import existing handlers
from media_handler import media_bp, init_media_directories
from location_handler import location_bp

# Import socket events
from socket_events import register_socket_events

# Import time here to avoid eventlet conflicts
import time

# Set timezone
os.environ['TZ'] = TIMEZONE
if hasattr(time, 'tzset'):
    time.tzset()

print(f"[DEBUG] Server starting at: {time.strftime('%Y-%m-%d %H:%M:%S')}")
print(f"[DEBUG] Timezone: {TIMEZONE}")

# ==================== SESSION HELPER ====================

def is_authenticated():
    """Enterprise-grade authentication check"""
    try:
        return (
            session.get('user_authenticated') == True and 
            session.get('user_id') is not None and
            session.get('user_id') != ''
        )
    except Exception as e:
        print(f"[AUTH] Session check failed: {e}")
        return False

def require_auth():
    """Check authentication and redirect if needed"""
    if not is_authenticated():
        print(f"[AUTH] Unauthorized access attempt - redirecting to login")
        return redirect('/login', code=302)
    return None

# ==================== FLASK APP INITIALIZATION ====================

# Create Flask app
app = Flask(__name__)

# Automatic cache busting - permanent solution
@app.context_processor
def inject_cache_version():
    """No more cache problems!"""
    return {'cache_version': datetime.now().strftime('%Y%m%d%H%M%S')}

# Initialize Flask-Login
login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'auth.login'

@login_manager.user_loader
def load_user(user_id):
    """Load user by ID for Flask-Login"""
    from flask_login import UserMixin
    class User(UserMixin):
        def __init__(self, id):
            self.id = id
    return User(user_id) if user_id else None

# Configure Flask app
app.config['SECRET_KEY'] = SECRET_KEY
app.config['PERMANENT_SESSION_LIFETIME'] = SESSION_LIFETIME
app.config['SESSION_COOKIE_NAME'] = SESSION_COOKIE_NAME
app.config['SESSION_COOKIE_SAMESITE'] = SESSION_COOKIE_SAMESITE
app.config['SESSION_COOKIE_SECURE'] = False  # HTTP mode for testing
app.config['SESSION_COOKIE_HTTPONLY'] = SESSION_COOKIE_HTTPONLY
app.config['SESSION_COOKIE_DOMAIN'] = SESSION_COOKIE_DOMAIN

# Set maximum file upload size to 3GB
app.config['MAX_CONTENT_LENGTH'] = MAX_FILE_SIZE  # 3GB for chunked uploads
print(f"[CONFIG] Max file upload size: {MAX_FILE_SIZE / (1024 * 1024 * 1024):.1f}GB")

os.environ['OAUTHLIB_INSECURE_TRANSPORT'] = '1'

# Enable CORS
# Enable CORS with credentials for React frontend
CORS(app, 
     resources={r"/*": {
         "origins": ["http://localhost:3000", "http://127.0.0.1:3000", "http://localhost:5000"],
         "supports_credentials": True,
         "allow_headers": ["Content-Type", "Authorization"],
         "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
     }})

# Initialize SocketIO with eventlet async mode
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet',
                    max_http_buffer_size=10 * 1024 * 1024)  # 10MB WebSocket buffer

init_message_socketio(socketio)

# Register socket events
register_socket_events(socketio)

# Register blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(user_bp)
app.register_blueprint(message_bp)
app.register_blueprint(media_bp)
app.register_blueprint(location_bp)
app.register_blueprint(database_bp)

# Biometric authentication (optional)
try:
    from biometric_auth import biometric_bp, init_biometric
    app.register_blueprint(biometric_bp)
    init_biometric(app)
    print("[SUCCESS] Biometric authentication loaded")
except ImportError:
    print("[INFO] Biometric authentication not available")

# Initialize media directories
init_media_directories()

# Initialize WebSocket handlers (commented out due to missing methods)
try:
    from websocket_media import MediaWebSocketHandler
    from websocket_location import LocationWebSocketHandler
    if hasattr(MediaWebSocketHandler, 'initialize'):
        MediaWebSocketHandler.initialize(socketio)
        print("‚úÖ [WS-MEDIA] WebSocket media handler initialized")
    if hasattr(LocationWebSocketHandler, 'initialize'):
        LocationWebSocketHandler.initialize(socketio)
        print("‚úÖ [WS-LOCATION] WebSocket location handler initialized")
except ImportError:
    print("[INFO] WebSocket handlers not available")

# ==================== CONTEXT PROCESSORS ====================

@app.context_processor
def inject_user_info():
    """Inject current user info into all templates"""
    if is_authenticated():
        user_id = session.get('user_id', '')
        user_name = session.get('user_name', '')
        user_role = session.get('user_role', 'client')
        user_profile_picture = session.get('user_profile_picture', '')
        
        return {
            'current_user': {
                'user_id': user_id,
                'name': user_name,
                'role': user_role,
                'profile_picture': user_profile_picture
            }
        }
    return {'current_user': None}

@app.context_processor
def inject_webrtc_config():
    """Inject WebRTC configuration into all templates"""
    return {
        'webrtc_config': get_webrtc_config(),
        'ice_servers': get_ice_servers()
    }

@app.context_processor 
def inject_app_info():
    """Inject app information"""
    return {
        'app_name': 'CA360 Chat',
        'app_version': '2.0',
        'debug_mode': True
    }

# ==================== STATIC FILES ====================

@app.route('/favicon.ico')
def favicon():
    return send_from_directory(os.path.join(app.root_path, 'static'), 'favicon.ico', mimetype='image/vnd.microsoft.icon')

@app.route('/static/<path:filename>')
def static_files(filename):
    return send_from_directory('static', filename)

# ==================== MAIN ROUTES ====================

@app.route('/')
def index():
    """Main chat interface - requires authentication"""
    auth_redirect = require_auth()
    if auth_redirect:
        return auth_redirect
    
    return render_template('index.html')

@app.route('/login')
def login_page():
    """Login page"""
    if is_authenticated():
        return redirect('/')
    return render_template('login.html')

# ==================== ICE SERVERS & WEBRTC ====================

@app.route('/api/ice-servers', methods=['GET'])
def get_ice_servers_endpoint():
    """
    Generate time-limited ICE servers for WebRTC connections
    
    Returns enterprise-grade STUN/TURN server configuration:
        - Google STUN (2 servers) - Primary IP discovery
        - Cloudflare STUN (1 server) - Backup IP discovery
        - Metered.ca TURN (4 endpoints) - Primary traffic relay
        - OpenRelay TURN (3 endpoints) - Backup traffic relay
    """
    import hmac
    import hashlib
    import base64
    
    try:
        # Generate time-limited credentials using HMAC-SHA1 (RFC 5389)
        timestamp = int(time.time()) + 86400  # Expires in 24 hours
        username = f"{timestamp}:ca360"
        
        credential = base64.b64encode(
            hmac.new(
                TURN_SECRET.encode(),
                username.encode(),
                hashlib.sha1
            ).digest()
        ).decode()
        
        # Get ICE servers from centralized config
        ice_servers = get_ice_servers()
        
        # Log credential generation
        print(f"[TURN] Generated credentials for session")
        print(f"[TURN] Metered.ca: {METERED_API_KEY[:10]}...")
        print(f"[TURN] OpenRelay: {OPENRELAY_USERNAME}")
        print(f"[TURN] Expires in: 24 hours")
        print(f"[TURN] Total ICE servers: {len(ice_servers)}")
        
        return jsonify({
            'success': True,
            'ice_servers': ice_servers,
            'ttl': 86400,  # Time to live in seconds (24 hours)
            'timestamp': int(time.time()),
            'expires_at': timestamp
        })
        
    except Exception as e:
        print(f"[TURN] Error generating credentials: {e}")
        import traceback
        traceback.print_exc()
        
        # Return minimal STUN-only fallback on error
        return jsonify({
            'success': False,
            'error': 'Failed to generate TURN credentials',
            'ice_servers': [
                {'urls': 'stun:stun.l.google.com:19302'},
                {'urls': 'stun:stun1.l.google.com:19302'}
            ],
            'ttl': 3600
        }), 500

# ==================== WEBRTC CONFIGURATION ENDPOINT ====================

@app.route('/api/webrtc-config', methods=['GET'])
def get_webrtc_configuration():
    """
    Get complete WebRTC configuration including quality settings
    
    Returns:
        JSON with full WebRTC configuration:
        - ICE servers
        - Quality settings (audio/video bitrates)
        - Timeout configurations
        - Feature flags
    """
    try:
        webrtc_config = get_webrtc_config()
        
        return jsonify({
            'success': True,
            'config': webrtc_config
        })
        
    except Exception as e:
        print(f"[WEBRTC] Error fetching config: {e}")
        return jsonify({
            'success': False,
            'error': 'Failed to fetch WebRTC configuration'
        }), 500

# ==================== HEALTH CHECK ====================

@app.route('/health')
def health_check():
    """Health check endpoint for Docker and monitoring"""
    return jsonify({
        'status': 'healthy',
        'timestamp': time.time(),
        'service': 'CA360 Chat',
        'version': '2.0',
        'features': {
            'websockets': True,
            'webrtc': True,
            'file_upload': True,
            'biometric_auth': False,
            'location_sharing': True
        },
        'config': {
            'max_file_size': MAX_FILE_SIZE,
            'timezone': TIMEZONE,
            'session_lifetime': str(SESSION_LIFETIME)
        }
    })

@app.route('/ping')
def ping():
    """Simple ping endpoint"""
    return jsonify({
        'status': 'ok', 
        'server': 'CA360 Chat',
        'timestamp': time.time(),
        'authenticated': is_authenticated(),
        'user_id': session.get('user_id', 'anonymous')
    })

# ==================== ERROR HANDLERS ====================

@app.errorhandler(404)
def not_found(error):
    """Handle 404 errors"""
    if request.path.startswith('/api/'):
        return jsonify({'error': 'API endpoint not found'}), 404
    return render_template('error.html', error_code=404, error_message="Page not found"), 404

@app.errorhandler(500)
def internal_error(error):
    """Handle 500 errors"""
    if request.path.startswith('/api/'):
        return jsonify({'error': 'Internal server error'}), 500
    return render_template('error.html', error_code=500, error_message="Internal server error"), 500

@app.errorhandler(413)
def request_entity_too_large(error):
    """Handle file too large errors"""
    return jsonify({
        'error': 'File too large',
        'max_size': f"{MAX_FILE_SIZE / (1024**3):.1f}GB"
    }), 413

# ============================================================================
# CALLING SYSTEM - WhatsApp Style Voice & Video Calls
# ============================================================================

@socketio.on('initiate_call')
def handle_call_initiate(data):
    """Handle call initiation from caller"""
    try:
        caller_id = session.get('user_id')
        target_user = data.get('target_user')
        call_type = data.get('call_type', 'audio')  # 'audio' or 'video'
        caller_name = data.get('caller_name', 'Unknown')
        
        if not caller_id or not target_user:
            return
        
        print(f"üìû [CALL] Initiated: {caller_id} ‚Üí {target_user} ({call_type})")
        
        # Emit incoming call to target user
        socketio.emit('call_incoming', {
            'caller_id': caller_id,
            'caller_name': caller_name,
            'call_type': call_type
        }, room=target_user)
        
        print(f"üì§ [CALL] Incoming call event sent to {target_user}")
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in initiate_call: {e}")

@socketio.on('call_accepted')
def handle_call_accepted(data):
    """Handle call acceptance from receiver"""
    try:
        receiver_id = session.get('user_id')
        caller_id = data.get('to_user')
        offer = data.get('offer')
        
        if not receiver_id or not caller_id or not offer:
            print(f"‚ùå [CALL] Missing data in call_accepted")
            return
        
        print(f"‚úÖ [CALL] Accepted: {receiver_id} accepted call from {caller_id}")
        
        # Send offer to caller
        socketio.emit('call_accepted', {
            'receiver_id': receiver_id,
            'offer': offer
        }, room=caller_id)
        
        print(f"üì§ [CALL] Offer sent to {caller_id}")
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in call_accepted: {e}")

@socketio.on('answer')
def handle_answer(data):
    """Handle WebRTC answer from caller"""
    try:
        caller_id = session.get('user_id')
        receiver_id = data.get('to_user')
        answer = data.get('answer')
        
        if not caller_id or not receiver_id or not answer:
            return
        
        print(f"üì¨ [CALL] Answer: {caller_id} ‚Üí {receiver_id}")
        
        # Send answer to receiver
        socketio.emit('answer', {
            'caller_id': caller_id,
            'answer': answer
        }, room=receiver_id)
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in answer: {e}")

@socketio.on('ice_candidate')
def handle_ice_candidate(data):
    """Handle ICE candidate exchange"""
    try:
        sender_id = session.get('user_id')
        target_user = data.get('to_user')
        candidate = data.get('candidate')
        
        if not sender_id or not target_user or not candidate:
            return
        
        # Forward ICE candidate to target user
        socketio.emit('ice_candidate', {
            'sender_id': sender_id,
            'candidate': candidate
        }, room=target_user)
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in ice_candidate: {e}")

@socketio.on('call_declined')
def handle_call_declined(data):
    """Handle call rejection"""
    try:
        receiver_id = session.get('user_id')
        caller_id = data.get('caller_id')
        
        if not receiver_id or not caller_id:
            return
        
        print(f"‚ùå [CALL] Declined: {receiver_id} declined call from {caller_id}")
        
        # Notify caller
        socketio.emit('call_declined', {
            'receiver_id': receiver_id
        }, room=caller_id)
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in call_declined: {e}")

@socketio.on('call_ended')
def handle_call_ended(data):
    """Handle call end"""
    try:
        sender_id = session.get('user_id')
        target_user = data.get('target_user')
        
        if not sender_id:
            return
        
        print(f"üì¥ [CALL] Ended: {sender_id} ‚Üí {target_user}")
        
        if target_user:
            # Notify other user
            socketio.emit('call_ended', {
                'sender_id': sender_id
            }, room=target_user)
        
    except Exception as e:
        print(f"‚ùå [CALL] Error in call_ended: {e}")

# ============================================================================
# END OF CALLING SYSTEM
# ============================================================================

# ==================== STARTUP BANNER ====================

def print_startup_banner():
    """Print beautiful startup banner with configuration info"""
    print("\n" + "="*70)
    print(" CA360 CHAT - ENTERPRISE CALLING SYSTEM")
    print("="*70)
    print(f"Started at: {time.strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"Timezone: {TIMEZONE}")
    print(f"Session Lifetime: {SESSION_LIFETIME}")
    print(f"Upload Limit: {MAX_FILE_SIZE / (1024**3):.1f}GB")
    print("\n" + "-"*70)
    print(" WebRTC Configuration")
    print("-"*70)
    print(f"STUN Servers: {len(GOOGLE_STUN_SERVERS) + 1}")
    print(f"TURN Providers: Metered.ca + OpenRelay")
    print(f"Metered.ca Key: {METERED_API_KEY[:10]}...")
    print(f"OpenRelay User: {OPENRELAY_USERNAME}")
    print(f"Credential TTL: 24 hours")
    print(f"Total ICE Servers: {len(get_ice_servers())}")
    print("-"*70)
    print(" üìû CALLING SYSTEM: Voice & Video Calls ENABLED")
    print("-"*70)
    print(" All systems operational")
    print("="*70 + "\n")

# Call startup banner
print_startup_banner()

# ==================== STARTUP ====================

@app.route('/sw.js')
def service_worker():
    """Serve service worker from static folder"""
    return send_from_directory('static', 'sw.js', mimetype='application/javascript')

@app.route('/static/manifest.json')
def manifest():
    """Serve manifest.json for PWA"""
    return send_from_directory('static', 'manifest.json', mimetype='application/json')

if __name__ == '__main__':
    import sys
    
    # Check for SSL flag
    use_ssl = '--ssl' in sys.argv
    
    if use_ssl:
        cert_path = 'cert.pem'
        key_path = 'key.pem'
        
        if os.path.exists(cert_path) and os.path.exists(key_path):
            print("\nüîí SSL MODE ENABLED")
            print(f"Certificate: {cert_path}")
            print(f"Private Key: {key_path}")
            print("\nAccess at: https://localhost:5000")
            print("Mobile test: https://YOUR_COMPUTER_IP:5000")
            print("\nBrowser will show security warning (normal for self-signed cert)")
            print("    Click 'Advanced' ‚Üí 'Proceed to localhost'")
            print("="*70 + "\n")
            
            socketio.run(
                app, 
                debug=True, 
                host='0.0.0.0', 
                port=5000,
                certfile=cert_path,      # Use certfile for eventlet
                keyfile=key_path,        # Use keyfile for eventlet
                allow_unsafe_werkzeug=True
            )
        else:
            print("\n‚ùå SSL MODE REQUESTED BUT CERTIFICATES NOT FOUND!")
            print("="*70)
            print("Generate certificates with:")
            print("   cd C:\\CA360_CHAT")
            print("   openssl req -x509 -newkey rsa:4096 -nodes -out cert.pem -keyout key.pem -days 365")
            print("   (Just press Enter for all prompts)")
            print("\nFalling back to HTTP mode...")
            print("WebRTC calls WILL NOT WORK without HTTPS!")
            print("="*70 + "\n")
            
            socketio.run(app, debug=True, host='0.0.0.0', port=5000, allow_unsafe_werkzeug=True)
    else:
        print("\n‚ö†Ô∏è  HTTP MODE (Insecure)")
        print("="*70)
        print("WARNING: WebRTC calls require HTTPS!")
        print("Camera/microphone access will be BLOCKED by browser!")
        print("\nTo enable HTTPS, run: python app.py --ssl")
        print("Access at: http://localhost:5000")
        print("="*70 + "\n")
        
        socketio.run(app, debug=True, host='0.0.0.0', port=5000, allow_unsafe_werkzeug=True)